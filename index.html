<!DOCTYPE html>
<!-- saved from url=(0088)https://confluence.fkinternal.com/plugins/viewsource/viewpagesrc.action?pageId=124263429 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>View Source</title>
        <link rel="canonical" href="https://confluence.fkinternal.com/pages/viewpage.action?pageId=$action.page.id">
        <script>
window.WRM=window.WRM||{};window.WRM._unparsedData=window.WRM._unparsedData||{};window.WRM._unparsedErrors=window.WRM._unparsedErrors||{};
WRM._unparsedData["com.atlassian.plugins.atlassian-plugins-webresource-plugin:context-path.context-path"]="\u0022\u0022";
if(window.WRM._dataArrived)window.WRM._dataArrived();</script>
<link type="text/css" rel="stylesheet" href="./View Source_files/batch.css" data-wrm-key="_super" data-wrm-batch-type="context" media="all">
<link type="text/css" rel="stylesheet" href="./View Source_files/batch(1).css" data-wrm-key="plugin.viewsource,-_super" data-wrm-batch-type="context" media="all">
<link type="text/css" rel="stylesheet" href="./View Source_files/batch(2).css" data-wrm-key="page,-_super" data-wrm-batch-type="context" media="all">
<link type="text/css" rel="stylesheet" href="./View Source_files/batch(3).css" data-wrm-key="editor-content,-_super" data-wrm-batch-type="context" media="all">
<link type="text/css" rel="stylesheet" href="./View Source_files/colors.css" media="all">

    </head>

    <body class="mceContentBody aui-theme-default wiki-content fullsize">
        <p>&nbsp;</p>         <h1>Replace global polyfills with reusable runtime helper polyfills:</h1><ul><li>We have been requiring polyfills directly in our code using&nbsp; <strong>require('@babel/polyfill')&nbsp;</strong>which basically imports all the polyfill functions that is implemented in the library. Most of those polyfill functions we are probably not even using in our application.</li><li>Other than that requiring this also pollutes the global scope which means it will attach its functions to the Global object.</li><li>This library is built on top of core-js which is the standard polyfilling library used by all applications. As of babel 7.4.0 they have deprecated the usage of babel/polyfill&nbsp; and recommend using core-js directly.<ul><li>Since this was deprecated it had stopped supporting some of the new features such as Promise.all which I noticed crashes our application in older browsers.</li></ul></li></ul><p><br></p><ul><li>We have now moved to using <strong>@babel/plugin-transform-runtime.&nbsp;</strong>This is a babel plugin that will enable the re-use of the polyfill functions to save on codesize. What it basically means that instead of transforming every instance of our code to its polyfill conunterpart, it will use helper functions that will be imported wherever required.</li><li>It will also not pollute the global scope of our application.</li><li>These helpers are referenced from&nbsp;<strong><span style="color: rgb(36,41,46);">@babel/runtime</span></strong><span style="color: rgb(36,41,46);">&nbsp;which&nbsp;is a library that contains Babel modular runtime helpers. It is also built on top of core-js and we can pass options to the plugin as to which version of core-js we want to use. </span></li><li><span style="color: rgb(36,41,46);">Using this approach not only reduced our bundle size but the newer functions such as Promise.all were also polyfilled properly.</span></li></ul><p><br></p><h1><span style="color: rgb(36,41,46);">De-duplication of 3rd party libraries:</span></h1><ul><li><span style="color: rgb(36,41,46);">What it basically means is to avoid the duplication of external libraries that we use, especially large ones such as lodash, moment etc.</span></li><li><span style="color: rgb(36,41,46);">Most of us know that npm creates a dependency tree when it is installing dependencies from our package.json, which would contain the dependency required directly by our app and also the sub-dependencies required by our&nbsp;dependencies (too many dependencies, I know).</span></li><li><span style="color: rgb(36,41,46);">Once npm resolves our parent&nbsp;dependencies it would move on to resolving the child&nbsp;dependencies.</span><ul><li><span style="color: rgb(36,41,46);">Older versions of npm would install the tree as is and include all the&nbsp;dependencies mentioned.</span></li><li><span style="color: rgb(36,41,46);">Newer versions though&nbsp;<span style="color: rgb(35,31,32);">implement a scheme of "flattening" the installed<span>&nbsp;</span></span><code>node_modules</code><span style="color: rgb(35,31,32);"><span>&nbsp;</span>dependency tree. What it means is&nbsp;some of these dependencies can be collapsed to one package.</span></span></li></ul></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">The flattening schemes are powerful but it works as long as long the libraries versions match.</span></span><ul><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">For eg: if we are using say moment@2.18.1 and one of our dependency is using moment@2.19.1 then npm would install and include both of these versions in the final bundle.</span></span></li></ul></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">By making sure that we use the same versions of libraries across,&nbsp; npm would not install the same package twice once it is resolved.&nbsp;</span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">I understand that this is not exactly ideal but we can use profiling techniques to figure out that at least the large libraries are not getting duplicated in our code.</span></span></li></ul><p><br></p><h1><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">Separation of vendor files on vertical level</span></span></h1><ul><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">This strategy doesn't exactly reduce the net bundle size as much as it&nbsp;segregates them on a vertical level.</span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">While profiling I noticed that there are some libraries that are very huge in size but are only being used by one vertical.&nbsp;</span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">So it made more sense to not include them in the common vendors as it will increase the time before first paint occurs, and might end up not even getting used if the user doesn't even have to visit that vertical.</span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">Segregation of the vendor files was done using <strong>SplitChunksPlugin</strong> which is out of the box available in webpack 4. Its an awesome plugin and I would recommend you to read more upon it if interested.</span></span></li></ul><p><br></p><h1><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">Enabling tree shaking in React UI Components</span></span></h1><ul><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">This strategy was by far the best one in reducing the overall bundle size.</span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">Tree shaking is the process of eliminating dead/unused code from our application.</span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);">While building, webpack marks the code it deems as dead/unused and plugins such as Uglify or Terser removes these codes thus reducing the final bundle size.</span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);"><span style="color: rgb(41,41,41);">Webpack follows the trail of import/export statements throughout the application, so if it sees something being imported but ultimately not being used, it considers that to be “dead code”, and will tree-shake it.</span></span></span></li><li><span style="color: rgb(36,41,46);"><span style="color: rgb(35,31,32);"><span style="color: rgb(41,41,41);">This also means that webpack will only recognise dead code if it is using Ecma Script Module(ESM)&nbsp; and not the commonJS format.</span></span></span></li><li><span style="color: rgb(36,41,46);">How we import our libraries also matter.&nbsp;For eg:</span><ul><li><span style="color: rgb(36,41,46);">If we write an import statement as <strong>import _ from 'lodash'</strong>&nbsp;webpack will assume we are using all of it : <em>Non tree shakable</em></span></li><li><span style="color: rgb(36,41,46);">If write it as&nbsp;<strong>import _get&nbsp;from 'loadsh/get'&nbsp;&nbsp;</strong>it will import the item directly from its respective folder :&nbsp;<em>tree shakable</em></span></li><li><span style="color: rgb(36,41,46);">If we write it as&nbsp;<strong>import&nbsp;{ get } from 'lodash',&nbsp;</strong>webpack will be able to tree shake it only if the main lodash file, collating and exporting the functions, is using ESM as webpack cannot tree shake commonJS.</span></li></ul></li><li>We follow the third approach while using our react-ui-components, but we used to transpile our react-ui-components to commonJS which was non tree shakable.</li><li>Because of this we were including the entire react-ui-components in our final bundle which was quite large.</li><li>Exporting our library as ESM would enable webpack to remove the unused components and reduce the final bundle size by a lot.</li></ul><p><br></p><ul><li>Some things to take care of while exporting your library as ESM:<ul><li><strong>Side effects:&nbsp;</strong><span style="color: rgb(41,41,41);">Just because Webpack can’t see a piece of code being used, doesn’t mean it can be safely tree-shaken. Some imports, simply by being included in the bundle, have an important impact on the application. A good example of this are global stylesheets, or a JavaScript file that sets up some global configuration.</span></li><li>In order to tell webpack that our application has side effects, we must denote it in our package.json file.</li><li><p class="auto-cursor-target">We do this by adding a property called sideEffects and including an array of files which we consider to be side effects.&nbsp;</p><table class="wysiwyg-macro" data-macro-name="code" data-macro-id="8c9c5fcb-fafb-4570-bac0-75fb047ba426" data-macro-parameters="language=js" data-macro-schema-version="1" style="background-image: url(https://confluence.fkinternal.com/plugins/servlet/confluence/placeholder/macro-heading?definition=e2NvZGU6bGFuZ3VhZ2U9anN9&amp;locale=en_US&amp;version=2); background-repeat: no-repeat;" data-macro-body-type="PLAIN_TEXT"><tbody><tr><td class="wysiwyg-macro-body"><pre>"sideEffects": [
"react-dates/initialize",
"*.css"
],</pre></td></tr></tbody></table><p class="auto-cursor-target"><br></p></li></ul></li></ul><p><br></p><h1>What we can do on a vertical level :</h1><ul><li>Start by using the profiler to find out areas of interest :&nbsp;<strong>npm run prod-dev:profile&nbsp;</strong>(this will give info about our bundle sizes as built for production)</li><li>Lean towards using lean 3rd party dependencies</li><li>Most libraries these days will ship an es6 version of their code which helps with tree shaking. Look for properties such as&nbsp;<strong>modules&nbsp;</strong>or&nbsp;<strong>jsnext:main&nbsp;</strong>in their package.json.</li><li>How we import our code also matters as pointed out above. It is best to import the component we want directly from the library's respective folder if they don't support tree shaking.</li><li>Try to avoid using image based svgs or large svgs directly in our codebase. Using CDN brings a lot of benefits.</li><li>Taking up blinx to react migration activities whenever possible. This will not only optimise our verticals but also help get rid of a lot of common extensions such as bootstrap, jquery and many custom extensions that we maintain.</li></ul><p><br></p><h1>Possible discussions:</h1><ul><li>We can discuss moving away from using moment. The owners of the library themselves encourage this.</li><li>Find a way to implement differential serving in our application. Basically serving modern code to modern browsers and polyfilled code to the old ones.</li></ul><p><br></p><h3>Few articles:</h3><p><a href="https://medium.com/@craigmiller160/how-to-fully-optimize-webpack-4-tree-shaking-405e1c76038">https://medium.com/@craigmiller160/how-to-fully-optimize-webpack-4-tree-shaking-405e1c76038</a></p><p><a href="https://formidable.com/blog/2018/finding-webpack-duplicates-with-inspectpack-plugin/">https://formidable.com/blog/2018/finding-webpack-duplicates-with-inspectpack-plugin/</a></p><p><a href="https://www.zzuu666.com/articles/9">https://www.zzuu666.com/articles/9</a></p><p><a href="https://web.dev/fast/#optimize-your-javascript">https://web.dev/fast/#optimize-your-javascript</a></p><p><br></p>
        <p>&nbsp;</p>
    

</body></html>
